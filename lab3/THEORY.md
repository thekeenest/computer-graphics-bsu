# Теория: Растровые алгоритмы

## Введение

Растеризация — это процесс преобразования векторных графических примитивов (линий, окружностей и других геометрических фигур) в растровое изображение, состоящее из пикселей. Этот процесс является фундаментальным для компьютерной графики.

---

## 1. Пошаговый алгоритм (Step-by-Step Algorithm)

### Принцип работы

Самый простой алгоритм растеризации линии. Основан на параметрическом представлении отрезка.

### Математическая основа

Для отрезка от точки $(x_1, y_1)$ до $(x_2, y_2)$:
- Определяется количество шагов: $steps = \max(|x_2 - x_1|, |y_2 - y_1|)$
- Вычисляются приращения: $\Delta x = \frac{x_2 - x_1}{steps}$, $\Delta y = \frac{y_2 - y_1}{steps}$
- На каждом шаге: $x_{i+1} = x_i + \Delta x$, $y_{i+1} = y_i + \Delta y$

### Алгоритм

```
1. Вычислить dx = x2 - x1, dy = y2 - y1
2. steps = max(|dx|, |dy|)
3. Вычислить приращения: x_inc = dx/steps, y_inc = dy/steps
4. x = x1, y = y1
5. Для i от 0 до steps:
   - Нарисовать пиксель в (round(x), round(y))
   - x = x + x_inc
   - y = y + y_inc
```

### Преимущества
- Простота реализации
- Легко понять принцип работы

### Недостатки
- Использует операции с плавающей точкой (медленно)
- Операции округления на каждом шаге
- Низкая производительность

---

## 2. Алгоритм ЦДА (Digital Differential Analyzer - DDA)

### Принцип работы

Улучшенная версия пошагового алгоритма. Использует инкрементальные вычисления для определения пикселей на линии.

### Математическая основа

Основан на дифференциальных уравнениях:
- $\frac{dy}{dx} = k$ — угловой коэффициент
- На каждом шаге одна координата увеличивается на 1, вторая — на $k$ или $1/k$

### Алгоритм

```
1. dx = x2 - x1, dy = y2 - y1
2. steps = max(|dx|, |dy|)
3. x_inc = dx / steps, y_inc = dy / steps
4. x = x1, y = y1
5. Для каждого шага от 0 до steps:
   - Нарисовать пиксель (round(x), round(y))
   - x += x_inc
   - y += y_inc
```

### Преимущества
- Относительно простая реализация
- Работает для всех наклонов линии

### Недостатки
- Операции с плавающей точкой
- Накопление ошибок округления
- Медленнее целочисленных алгоритмов

---

## 3. Алгоритм Брезенхема для линий (Bresenham's Line Algorithm)

### Принцип работы

Использует только целочисленную арифметику для определения ближайших пикселей к идеальной линии.

### Математическая основа

Вместо вычисления реальных координат, алгоритм отслеживает ошибку отклонения:
- $error = dx - dy$
- Решение принимается на основе знака $2 \times error$

### Алгоритм

```
1. dx = |x2 - x1|, dy = |y2 - y1|
2. sx = sign(x2 - x1), sy = sign(y2 - y1)
3. err = dx - dy
4. x = x1, y = y1
5. Пока не достигнута конечная точка:
   - Нарисовать пиксель (x, y)
   - e2 = 2 * err
   - Если e2 > -dy: err -= dy, x += sx
   - Если e2 < dx: err += dx, y += sy
```

### Преимущества
- Только целочисленные операции (быстро)
- Высокая точность
- Эффективное использование памяти
- Работает для всех октантов

### Недостатки
- Сложнее в понимании, чем DDA
- Создает "ступеньки" (алиасинг)

---

## 4. Алгоритм Брезенхема для окружностей (Bresenham's Circle Algorithm)

### Принцип работы

Использует симметрию окружности — вычисляет пиксели только для одной восьмой части окружности, остальные получает отражением.

### Математическая основа

Уравнение окружности: $(x - x_c)^2 + (y - y_c)^2 = r^2$

Функция принятия решения: $d = 3 - 2r$

### Алгоритм

```
1. x = 0, y = r
2. d = 3 - 2 * r
3. Пока x <= y:
   - Нарисовать 8 симметричных пикселей
   - x++
   - Если d > 0:
     - y--
     - d = d + 4*(x - y) + 10
   - Иначе:
     - d = d + 4*x + 6
```

### 8 симметричных точек
Для каждой точки $(x, y)$ относительно центра $(x_c, y_c)$:
- $(x_c ± x, y_c ± y)$
- $(x_c ± y, y_c ± x)$

### Преимущества
- Только целочисленные операции
- Высокая производительность
- Использует симметрию (вычисляет 1/8 окружности)

### Недостатки
- Работает только для окружностей
- Видны ступеньки при малых радиусах

---

## 5. Алгоритм Ву (Wu's Line Algorithm)

### Принцип работы

Алгоритм сглаживания (anti-aliasing), который рисует линии с частичной интенсивностью пикселей, создавая визуально гладкую линию.

### Математическая основа

Использует дробные части координат для определения интенсивности пикселей:
- $intensity = 1 - \text{fpart}(y)$ — для основного пикселя
- $intensity = \text{fpart}(y)$ — для соседнего пикселя

Где $\text{fpart}(x) = x - \lfloor x \rfloor$ — дробная часть числа.

### Алгоритм

```
1. Если |dy| > |dx|: поменять x и y местами
2. Если x1 > x2: поменять точки местами
3. dx = x2 - x1, dy = y2 - y1
4. gradient = dy / dx
5. Для каждого x от x1 до x2:
   - y = y_начальное + gradient * (x - x1)
   - Нарисовать пиксель (x, floor(y)) с яркостью 1 - fpart(y)
   - Нарисовать пиксель (x, floor(y)+1) с яркостью fpart(y)
```

### Преимущества
- Создает сглаженные линии (anti-aliasing)
- Визуально качественный результат
- Устраняет эффект "лестницы"

### Недостатки
- Использует операции с плавающей точкой
- Медленнее алгоритма Брезенхема
- Требует поддержки прозрачности/интенсивности

---

## 6. Алгоритм Кастла-Питвея (Castle-Pitway Algorithm)

### Принцип работы

Обобщение алгоритма Брезенхема, которое корректно работает для всех направлений и октантов. Использует целочисленные вычисления для минимизации ошибки между идеальной линией и растровыми координатами.

### Математическая основа

Аналогична алгоритму Брезенхема, но с улучшенной логикой обработки всех направлений:
- Начальная ошибка: $err = dx - dy$
- На каждом шаге: $e2 = 2 \times err$
- Коррекция ошибки зависит от соотношения $e2$ с $dx$ и $dy$

### Алгоритм

```
1. dx = |x2 - x1|, dy = |y2 - y1|
2. sx = 1 если x1 < x2 иначе -1
3. sy = 1 если y1 < y2 иначе -1
4. err = dx - dy
5. Пока не достигнута конечная точка (x2, y2):
   - Нарисовать пиксель (x1, y1)
   - e2 = 2 * err
   - Если e2 > -dy:
     - err -= dy
     - x1 += sx
   - Если e2 < dx:
     - err += dx
     - y1 += sy
```

### Преимущества
- Только целочисленные операции
- Работает для всех октантов без специальных случаев
- Высокая эффективность
- Точный результат

### Недостатки
- Практически идентичен Брезенхему (часто это один и тот же алгоритм)
- Создает "ступеньки" (нет сглаживания)

---

## Сравнительная таблица

| Алгоритм | Тип операций | Сглаживание | Скорость | Сложность реализации |
|----------|--------------|-------------|----------|---------------------|
| Пошаговый | Плавающая точка | Нет | Низкая | Очень простая |
| ЦДА | Плавающая точка | Нет | Средняя | Простая |
| Брезенхем (линия) | Целочисленные | Нет | Высокая | Средняя |
| Брезенхем (окружность) | Целочисленные | Нет | Высокая | Средняя |
| Ву | Плавающая точка | Да | Средняя | Сложная |
| Кастл-Питвей | Целочисленные | Нет | Высокая | Средняя |

---

## Практическое применение

### Когда использовать каждый алгоритм:

1. **Пошаговый / ЦДА**: Обучение, прототипирование, когда производительность не критична
2. **Брезенхем**: Когда нужна высокая скорость и эффективность (игры, CAD-системы)
3. **Алгоритм Ву**: Когда важно качество изображения и нужно сглаживание (графические редакторы, печать)
4. **Кастл-Питвей**: Универсальное решение для различных направлений линий

---

## Ключевые понятия

### Алиасинг (Aliasing)
Эффект "лестницы" или "зубчатости" на линиях из-за дискретной природы растра.

### Анти-алиасинг (Anti-aliasing)
Техника сглаживания краев путем использования пикселей промежуточной интенсивности.

### Октанты
Восемь направлений в 2D-пространстве относительно центральной точки (0°-45°, 45°-90°, 90°-135° и т.д.).

### Инкрементальные алгоритмы
Алгоритмы, которые используют результаты предыдущего шага для вычисления следующего (ЦДА, Брезенхем).

---

## Заключение

Растровые алгоритмы — основа компьютерной графики. Выбор алгоритма зависит от требований:
- **Скорость** → Брезенхем, Кастл-Питвей
- **Качество** → Алгоритм Ву
- **Простота** → Пошаговый, ЦДА

Современные GPU реализуют аппаратные версии этих алгоритмов для максимальной производительности.
